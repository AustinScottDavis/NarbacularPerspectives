<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Paxtan Laker</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

    <h1 align="middle">CS 184: Computer Graphics and Imaging</h1>
    <h1 align="middle">Narbacular Perspective(s) [Final Report]</h1>
    <h2 align="middle">Paxtan Laker, Austin Davis, Emily Nguyen</h2>

    <br /><br />
    <div align="middle">
        <table style="width=100%">
            <tr>
                <td>
                    <img src="images/cutePortal.jpg" align="middle" width="400px" />
                </td>
            </tr>
            <br />

        </table>
    </div>
    <br /><br />

    <br />
    <a href="milestone.html" align="center">Milestone Report</a>
    <a href="proposal.html" align="center">Proposal</a>


    <h2 align="left">Abstract</h2>
    <p>
      some technical abstract

    </p>


    <hr />

    <h2 align="left">Background</h2>
    <p>
      Imagine Valve’s Portal: a world where the user can create a portal anywhere and peer out into a different world.
      <br><br>
      Portal is a 2007 puzzle-platform game developed and published by Valve. It consists of a series of puzzles that must be solved by teleporting the player's character, using a device that can create inter-spatial portals between two flat planes.

      <br><br>
      This project strives to put a modern twist on the classic concepts found in Valve’s Portal. Both from a graphics implementation and conceptual perspective, the idea of portals is incredibly intriguing.

      This project is a demonstration of a world in which a user can create multiple portals and peer or walk through them to a different location, similar to Valve's Portal. However, this project extends further from the original video game to allow for the user to create portals of varying sizes and in any location. The idea behind having portals of different sizes is that they will scale the size of objects pass through them relative to the ratios of their area.
    </p>

    <hr />
    <h2 align="left">Technical Approach</h2>
    <p>
        -A 1-2 page summary of your technical approach, techniques used, algorithms implemented, etc. (use references to papers or other resources for further detail). Highlight how your approach varied from the references used (did you implement a subset, or did you change or enhance anything), the unique decisions you made and why.
        <br />
        -A description of problems encountered and how you tackled them.
        <br />
        -A description of lessons learned.
    </p>
    <h3 align="left">1. First Person Character, Gun, Scene and Game Management</h3>
    <p> We created a first person controller script that will allow us to move a character sprite around the scene. We also created a gun with physical projectives, audio, and physics. Luckily we are part of the VR DeCal so we were able to steal the basic first person controller and gun from a homework we designed a couple semesters ago (really it's just from Unity's packages)<sup>[1]</sup>.  Both these elements allow us to interact with the portals created later in the project and check that physics and momentum are conserved when moving through portals.
    <br><br>
    We then created manager scripts in order to give a general API and abstraction for portal creation, pairing, and rendering. These scripts set up the stage for debugging as we manually create and test our Portals class here.
    <br><br>
    There's a likely chance that the player is going to create portals in which they can view themself, so we also decided to add a character model with standard physics properties.
    </p>

    <h3 align="left">2. Portal Rendering</h3>
    <h4 align="left">Portal Pairing and Camera Movement</h4>
    <p> The first thing we had to do was figure out how we wanted the portals to work under the hood. There are about 1000 different ways you can do portals, but we decided to basically pursue a camera rendering route where each portal has a camera that follows it's respective paired portal using local coordinate translation.</p>
    <p> Suppose you are looking through Portal 1 at a 2 height, 3 width offset at a 60 degree angle (you = your fps model). For getting the correct camera view in respect to Portal 2, you need to translate these deltas to the other portal using local coordinates. Basically, you would want your paired camera to be at a 2 height, 3 width offset (and 60 degree angle) from Portal 2 with respect to the OPPOSITE normal. This gets into some weird math, but basically if you are in front of your Portal 1, you actually need your paired camera to be BEHIND portal 2 to get the correct viewpoint. This is a simple rotational matrix conversion, but it took a while to figure out and debug.</p>
    <p> Just to make sure we are on the same page --> Each portal is going to have a paired camera that is generally behind it's paired portal. I'm going to link some videos showcasing our progress on this below, but it's important to understand that we have these paired cameras so that we can basically emulate our character standing there and render what you would be seeing if you had "preemptively" gone through the portal and could see the other side. There is some image cropping, texture mapping, and rendering stuff related to this we have to talk about later, but ultimately that's the main idea.</p>

    <h4 align="left">Custom Portal Shader</h4>
    <p> In order to get the view from each of these cameras onto the portals, we created a custom shader that was applied to the quad on each of the portals. We first set the output of each camera to a RenderTexture and applied these to each portal’s quad material. This naïve approach didn’t look quite right because it was applied the entire view of the camera to the portal, when we only wanted a cropped version of this with dimensions based on the direction and distance the player was looking at the portal from.</p>
    <p> To fix this, we created a custom shader for the portals that would take the texture generated from the camera view, but instead of using the entire thing, it only used the part that corresponding to the UV coordinates of each position in screen space for the player. This gave us the cropping effect that can be seen in the third video below. With this custom shader, we were then also able to make the surface of the portals unlit so that they do not reflect light as if they were a flat wall.</p>
    <p> We also took into account the fact that there could be objects in between the camera and the back of the portal that we did not want to be rendered. We solved this problem by changing the near clip plane of each of the cameras to be an oblique projection from the camera to the portal’s plane. This way it would only render objects in front of the portal which also allows us to place these portals directly onto walls without any clipping. The equation we used to solve for these oblique projections can be found in the sources below and is also cited in our code. </p>

    <h4 align="left">Recursive Portal Rendering</h4>
    <p> At this point, looking through portals looks very natural and convincing. However, there is still a problem if two paired portals are facing each other and you try to look at one of the portals through the other portal. Each frame, it shows the view of the paired portal from the previous frame which gives it this Windows XP Solitaire victory effect. </p>
    <p> This problem necessitated rendering each portal’s view multiple times, and from different positions and angles. The algorithm works like this: Each frame, we calculate the appropriate position and rotation of the portal camera based on the position of the player. We then calculate the position and rotation again, but using the new position and rotation from the portal camera that we just calculated. We keep calculating this any number of times equal to the recursiveRenderLimit that we set. Naturally, this severally impacts performance, so we kept it somewhere between 5 and 10. Finally, we render the portal camera at each of these positions and rotations in reverse order (the view farthest away is rendered first, and the closest view that was the only one we were using previously is rendered last). This gives a very nice recursive portal effect that is similar to the effect you would get if you pointed two mirrors at each other. </p>

    <h3 align="left">3. Teleportation</h3>
    <h4 align="left">Cloning</h4>
    <p> Insert text here.</p>
    <h4 align="left">Deadzones</h4>
    <p> Insert text here.</p>
    <h4 align="left">Cross Section Shader</h4>
    <p> Insert text here.</p>
    <h4 align="left">Portal and Object Scaling</h4>
    <p> Insert text here.</p>

    <h3 align="left">4. Portal Creation</h3>
    <p> Insert text here.</p>

    <hr />

    <h2 align="left">Results</h2>
    <p>
        Your final images, animations, video of your system (whichever is relevant). You can include results that you think show off what you built but that you did not have time to go over on presentation day.

    </p>

    <hr />

    <h2 align="left">References</h2>

    <p>
        <sup>[1]</sup>  https://xr.berkeley.edu/decal/hw5
        <br>
        <sup>[2]</sup>  https://math.stackexchange.com/questions/1568091/find-points-of-rectangle-given-two-diagonal-points-and-a-normal-in-3d
        <br>
        https://en.wikipedia.org/wiki/Portal_(video_game)
        <br>

        http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
        <br>

        https://www.youtube.com/watch?v=riijspB9DIQ
        <br>

        https://www.youtube.com/watch?v=_SmPR5mvH7w&t=321s
        <br>
    </p>
    <hr />



    <h2 align="left">Contributions</h2>
    <p>
        A clear description of the work contributed by each team member.
    </p>

    <ul>

        Paxtan:

        <ul>
            <br />
            <li>
                blah
            </li>
            <br />
        </ul>

        Austin:
        <ul>
            <br />
            <li>
                blah
            </li>
            <br />
        </ul>

        Emily

        <ul>
            <br />
            <li>
              blah
            </li>
            <br />

        </ul>
    </ul>
    <hr />

    </p>

</body>
</html>
